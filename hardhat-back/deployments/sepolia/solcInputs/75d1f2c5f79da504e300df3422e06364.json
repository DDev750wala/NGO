{
  "language": "Solidity",
  "sources": {
    "contracts/CryptoDonationPlatform.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.8;\r\n\r\n\r\ncontract NGOFunding {\r\n    address public owner;\r\n    uint256 constant VOTING_PERIOD = 7 days; \r\n    uint256 constant REFUND_WINDOW = 90 days;\r\n    uint256 constant VOTER_REWARD_PERCENTAGE = 5; \r\n    uint256 constant VOTING_THRESHOLD = 50;\r\n\r\n\r\n    struct NGO {\r\n        string name;\r\n        string description;\r\n        uint256 stakedEth;\r\n        string logo;\r\n        uint256[] taskIds; \r\n    }\r\n\r\n\r\n    struct Voter {\r\n        uint256 stakedEth;\r\n        mapping(uint256 => bool) hasVoted;\r\n    }\r\n\r\n\r\n    struct Task {\r\n        address ngo;\r\n        string[] proofLinks; // proof links\r\n        string status; // \"pending\", \"approved\", \"rejected\"\r\n        uint256 yesVotes;\r\n        uint256 noVotes;\r\n        uint256 totalFunds;\r\n        uint256 startTime;\r\n        mapping(address => bool) voters; \r\n        uint256 voterCount; \r\n    }\r\n\r\n\r\n    struct Donation {\r\n        address donor;\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n    }\r\n\r\n\r\n    mapping(address => NGO) public ngos;  //NGO wallet Address -> NGO\r\n    mapping(address => Voter) public voters; //Voter wallet Address-> Voter\r\n    mapping(uint256 => Task) public tasks; //Task_id -> Task\r\n    mapping(uint256 => Donation[]) public taskDonations; // Task ID => Donations\r\n    uint256 public taskCounter;\r\n    address[] public ngoList; // Array to track all NGOs\r\n    event NGOStakeWithdrawn(address ngo, uint256 amount);\r\n\r\n\r\n    // Events\r\n    event NGORegistered(address ngo, string name);\r\n    event VoterRegistered(address voter, uint256 stakedEth);\r\n    event TaskCreated(uint256 taskId, address ngo);\r\n    event Donated(uint256 taskId, address donor, uint256 amount, uint256 donationId);\r\n    event Voted(uint256 taskId, address voter, bool vote);\r\n    event TaskResolved(uint256 taskId, string status);\r\n\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner can call this\");\r\n        _;\r\n    }\r\n\r\n    function registerNGO(string memory _name, string memory _description, string memory _logo) external payable {\r\n        require(msg.value > 0, \"Must stake ETH\");\r\n        require(ngos[msg.sender].stakedEth == 0, \"NGO already registered\");\r\n\r\n\r\n        ngos[msg.sender] = NGO({\r\n            name: _name,\r\n            description: _description,\r\n            stakedEth: msg.value,\r\n            taskIds: new uint256[](0),\r\n            logo : _logo\r\n        });\r\n\r\n\r\n        ngoList.push(msg.sender);\r\n\r\n\r\n        emit NGORegistered(msg.sender, _name);\r\n    }\r\n\r\n\r\n    function registerVoter() external payable {\r\n        require(msg.value > 0, \"Must stake ETH\"); //minimum stack eth validation\r\n        require(voters[msg.sender].stakedEth == 0, \"Already a voter\"); //If stacked etr is 0 then not voter\r\n\r\n\r\n        voters[msg.sender].stakedEth = msg.value;\r\n        emit VoterRegistered(msg.sender, msg.value);\r\n    }\r\n\r\n\r\n    function createTask(string[] memory _proofLinks) external {\r\n        require(ngos[msg.sender].stakedEth > 0, \"NGO not registered\"); //NGO must be registered\r\n\r\n\r\n        taskCounter++;\r\n        Task storage newTask = tasks[taskCounter];\r\n        newTask.ngo = msg.sender;\r\n        newTask.proofLinks = _proofLinks;\r\n        newTask.status = \"pending\";\r\n        newTask.startTime = block.timestamp;\r\n\r\n\r\n        ngos[msg.sender].taskIds.push(taskCounter); //store task to ngo's struct\r\n        emit TaskCreated(taskCounter, msg.sender);\r\n    }\r\n\r\n    function donate(uint256 _taskId) external payable {\r\n        require(tasks[_taskId].ngo != address(0), \"Task does not exist\"); //task validation\r\n        require(msg.value > 0, \"Must donate ETH\");  //must to donate etr\r\n        require(keccak256(bytes(tasks[_taskId].status)) == keccak256(bytes(\"pending\")), \"Task not pending\"); //task status must be pending to donate etr\r\n\r\n\r\n        tasks[_taskId].totalFunds += msg.value;\r\n        taskDonations[_taskId].push(Donation({\r\n            donor: msg.sender,\r\n            amount: msg.value,\r\n            timestamp: block.timestamp\r\n        }));\r\n\r\n\r\n        emit Donated(_taskId, msg.sender, msg.value, taskDonations[_taskId].length - 1);\r\n    }\r\n\r\n    function vote(uint256 _taskId, bool _approve) external {\r\n        require(voters[msg.sender].stakedEth > 0, \"Not a voter\"); //must be voter\r\n        require(tasks[_taskId].ngo != address(0), \"Task does not exist\"); //task musut be exsist\r\n        require(!voters[msg.sender].hasVoted[_taskId], \"Already voted\"); // voter must not voted prior\r\n        require(keccak256(bytes(tasks[_taskId].status)) == keccak256(bytes(\"pending\")), \"Task not pending\"); //Task must be in panding state\r\n        require(block.timestamp <= tasks[_taskId].startTime + VOTING_PERIOD, \"Voting period ended\"); //vote before voting period\r\n\r\n\r\n        voters[msg.sender].hasVoted[_taskId] = true;\r\n        tasks[_taskId].voters[msg.sender] = true;\r\n        tasks[_taskId].voterCount++;\r\n\r\n\r\n        if (_approve) {\r\n            tasks[_taskId].yesVotes++;\r\n        } else {\r\n            tasks[_taskId].noVotes++;\r\n        }\r\n\r\n\r\n        emit Voted(_taskId, msg.sender, _approve);\r\n    }\r\n\r\n    function resolveTask(uint256 _taskId) external {\r\n        Task storage task = tasks[_taskId];\r\n        require(task.ngo != address(0), \"Task does not exist\");\r\n        require(keccak256(bytes(task.status)) == keccak256(bytes(\"pending\")), \"Task already resolved\");\r\n        require(block.timestamp > task.startTime + VOTING_PERIOD, \"Voting period not ended\");\r\n\r\n        uint256 voterRewardPool = task.voterCount > 0 ? (task.totalFunds * VOTER_REWARD_PERCENTAGE) / 100 : 0;\r\n        uint256 remainingFunds = task.totalFunds - voterRewardPool;\r\n\r\n\r\n        uint256 totalVotes = task.yesVotes + task.noVotes;\r\n        if (totalVotes > 0 && (task.yesVotes * 100 / totalVotes) >= VOTING_THRESHOLD) {\r\n            // Approved: Send remaining funds to NGO\r\n            task.status = \"approved\";\r\n            (bool sentNgo, ) = task.ngo.call{value: remainingFunds}(\"\");\r\n            require(sentNgo, \"Failed to send funds to NGO\");\r\n        } else {\r\n            // Rejected: Refund donors with remaining funds\r\n            task.status = \"rejected\";\r\n            uint256 totalDonated = 0;\r\n            for (uint256 i = 0; i < taskDonations[_taskId].length; i++) {\r\n                totalDonated += taskDonations[_taskId][i].amount;\r\n            }\r\n            for (uint256 i = 0; i < taskDonations[_taskId].length; i++) {\r\n                Donation memory donation = taskDonations[_taskId][i];\r\n                uint256 refundAmount = (donation.amount * remainingFunds) / totalDonated; // Proportional refund\r\n                (bool sent, ) = donation.donor.call{value: refundAmount}(\"\");\r\n                require(sent, \"Refund failed\");\r\n            }\r\n        }\r\n\r\n\r\n        emit TaskResolved(_taskId, task.status);\r\n    }\r\n\r\n\r\n    function withdrawVoterStake() external {\r\n        require(voters[msg.sender].stakedEth > 0, \"Not a voter\");\r\n\r\n\r\n        uint256 amount = voters[msg.sender].stakedEth;\r\n        voters[msg.sender].stakedEth = 0;\r\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\r\n        require(sent, \"Withdrawal failed\");\r\n    }\r\n\r\n\r\n    function withdrawNgoStake() external {\r\n        require(ngos[msg.sender].stakedEth > 0, \"Not an NGO or already withdrawn\");\r\n\r\n\r\n        NGO storage ngo = ngos[msg.sender];\r\n        for (uint256 i = 0; i < ngo.taskIds.length; i++) {\r\n            Task storage task = tasks[ngo.taskIds[i]];\r\n            if (keccak256(bytes(task.status)) == keccak256(bytes(\"pending\")) &&\r\n                block.timestamp <= task.startTime + VOTING_PERIOD) {\r\n                revert(\"Cannot withdraw with pending tasks\");\r\n            }\r\n        }\r\n\r\n\r\n        uint256 amount = ngo.stakedEth;\r\n        ngo.stakedEth = 0; // Reset stake\r\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\r\n        require(sent, \"Withdrawal failed\");\r\n\r\n\r\n        emit NGOStakeWithdrawn(msg.sender, amount);\r\n    }\r\n\r\n    function claimVoterReward(uint256 _taskId) external {\r\n        require(tasks[_taskId].voters[msg.sender], \"Did not vote on task\");\r\n        require(keccak256(bytes(tasks[_taskId].status)) != keccak256(bytes(\"pending\")), \"Task still pending\");\r\n\r\n\r\n        uint256 voterRewardPool = (tasks[_taskId].totalFunds * VOTER_REWARD_PERCENTAGE) / 100;\r\n        uint256 reward = tasks[_taskId].voterCount > 0 ? voterRewardPool / tasks[_taskId].voterCount : 0;\r\n\r\n\r\n        (bool sent, ) = msg.sender.call{value: reward}(\"\");\r\n        require(sent, \"Reward claim failed\");\r\n\r\n\r\n        tasks[_taskId].voters[msg.sender] = false; // Prevent double claim\r\n    }\r\n\r\n\r\n    // Getter Functions\r\n    function getAllNGOs() external view returns (address[] memory) {\r\n        return ngoList;\r\n    }\r\n\r\n\r\n    function getNGODetails(address _ngo) external view returns (\r\n        string memory name,\r\n        string memory description,\r\n        uint256 stakedEth,\r\n        uint256[] memory taskIds\r\n    ) {\r\n        NGO storage ngo = ngos[_ngo];\r\n        require(ngo.stakedEth > 0, \"NGO not registered\");\r\n        return (ngo.name, ngo.description, ngo.stakedEth, ngo.taskIds);\r\n    }\r\n\r\n\r\n    function getNGOTaskStatuses(address _ngo) external view returns (uint256[] memory taskIds, string[] memory statuses) {\r\n        NGO storage ngo = ngos[_ngo];\r\n        require(ngo.stakedEth > 0, \"NGO not registered\");\r\n\r\n\r\n        taskIds = ngo.taskIds;\r\n        statuses = new string[](taskIds.length);\r\n\r\n\r\n        for (uint256 i = 0; i < taskIds.length; i++) {\r\n            statuses[i] = tasks[taskIds[i]].status;\r\n        }\r\n\r\n\r\n        return (taskIds, statuses);\r\n    }\r\n\r\n\r\n    function getAllTasks() external view returns (uint256[] memory) {\r\n        uint256[] memory allTasks = new uint256[](taskCounter);\r\n        for (uint256 i = 1; i <= taskCounter; i++) {\r\n            allTasks[i - 1] = i;\r\n        }\r\n        return allTasks;\r\n    }\r\n\r\n\r\n    function getTaskDetails(uint256 _taskId) external view returns (\r\n        address ngo,\r\n        string[] memory proofLinks,\r\n        string memory status,\r\n        uint256 yesVotes,\r\n        uint256 noVotes,\r\n        uint256 totalFunds,\r\n        uint256 startTime,\r\n        uint256 voterCount\r\n    ) {\r\n        Task storage task = tasks[_taskId];\r\n        require(task.ngo != address(0), \"Task does not exist\");\r\n        return (task.ngo, task.proofLinks, task.status, task.yesVotes, task.noVotes, task.totalFunds, task.startTime, task.voterCount);\r\n    }\r\n\r\n\r\n    function getVoterDetails(address _voter) external view returns (uint256 stakedEth) {\r\n        return voters[_voter].stakedEth;\r\n    }\r\n\r\n\r\n    function hasVoted(address _voter, uint256 _taskId) external view returns (bool) {\r\n        return voters[_voter].hasVoted[_taskId];\r\n    }\r\n\r\n\r\n    function getDonations(uint256 _taskId) external view returns (Donation[] memory) {\r\n        return taskDonations[_taskId];\r\n    }\r\n\r\n\r\n    function getNGOTotalFunds(address _ngo) external view returns (uint256 totalFunds) {\r\n        NGO storage ngo = ngos[_ngo];\r\n        require(ngo.stakedEth > 0, \"NGO not registered\");\r\n\r\n\r\n        totalFunds = 0;\r\n        for (uint256 i = 0; i < ngo.taskIds.length; i++) {\r\n            if (keccak256(bytes(tasks[ngo.taskIds[i]].status)) == keccak256(bytes(\"approved\"))) {\r\n                totalFunds += tasks[ngo.taskIds[i]].totalFunds;\r\n            }\r\n        }\r\n        return totalFunds;\r\n    }\r\n\r\n\r\n    function getPendingTasks() external view returns (uint256[] memory) {\r\n        uint256 pendingCount = 0;\r\n        for (uint256 i = 1; i <= taskCounter; i++) {\r\n            if (keccak256(bytes(tasks[i].status)) == keccak256(bytes(\"pending\")) &&\r\n                block.timestamp <= tasks[i].startTime + VOTING_PERIOD) {\r\n                pendingCount++;\r\n            }\r\n        }\r\n\r\n\r\n        uint256[] memory pendingTasks = new uint256[](pendingCount);\r\n        uint256 index = 0;\r\n        for (uint256 i = 1; i <= taskCounter; i++) {\r\n            if (keccak256(bytes(tasks[i].status)) == keccak256(bytes(\"pending\")) &&\r\n                block.timestamp <= tasks[i].startTime + VOTING_PERIOD) {\r\n                pendingTasks[index] = i;\r\n                index++;\r\n            }\r\n        }\r\n        return pendingTasks;\r\n    }\r\n   \r\n}\r\n\r\n\r\n\r\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}